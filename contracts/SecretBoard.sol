// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, eaddress, externalEaddress} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/**
 * @title SecretBoard
 * @notice Stores encrypted messages whose decryption keys become publicly decryptable through Zama FHE.
 */
contract SecretBoard is ZamaEthereumConfig {
    struct Message {
        address author;
        uint256 timestamp;
        string encryptedContent;
        eaddress encryptedKey;
    }

    error EmptyContent();
    error MessageDoesNotExist();

    Message[] private _messages;

    event MessagePosted(
        uint256 indexed messageId,
        address indexed author,
        string encryptedContent,
        bytes32 encryptedKeyHandle
    );

    /**
     * @notice Post a new encrypted message to the board.
     * @param encryptedContent Ciphertext of the message produced off-chain using a random address key.
     * @param encryptedRandomAddress Encrypted handle of the random address key produced with the relayer SDK.
     * @param inputProof Proof generated by the relayer SDK for the encrypted handle.
     * @return messageId Index of the stored message.
     */
    function postMessage(
        string calldata encryptedContent,
        externalEaddress encryptedRandomAddress,
        bytes calldata inputProof
    ) external returns (uint256 messageId) {
        if (bytes(encryptedContent).length == 0) {
            revert EmptyContent();
        }

        eaddress encryptedKey = FHE.fromExternal(encryptedRandomAddress, inputProof);
        encryptedKey = FHE.makePubliclyDecryptable(encryptedKey);

        Message memory message = Message({
            author: msg.sender,
            timestamp: block.timestamp,
            encryptedContent: encryptedContent,
            encryptedKey: encryptedKey
        });

        _messages.push(message);
        messageId = _messages.length - 1;

        emit MessagePosted(messageId, msg.sender, encryptedContent, eaddress.unwrap(encryptedKey));
    }

    /**
     * @notice Get the total number of stored messages.
     */
    function messageCount() external view returns (uint256) {
        return _messages.length;
    }

    /**
     * @notice Retrieve a single message by index.
     * @param messageId Index of the message in storage.
     */
    function getMessage(uint256 messageId) external view returns (Message memory) {
        if (messageId >= _messages.length) {
            revert MessageDoesNotExist();
        }
        return _messages[messageId];
    }

    /**
     * @notice Return all stored messages.
     */
    function getMessages() external view returns (Message[] memory) {
        return _messages;
    }
}
